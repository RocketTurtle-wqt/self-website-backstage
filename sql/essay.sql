/*
 Navicat MySQL Data Transfer

 Source Server         : wqt's database
 Source Server Type    : MySQL
 Source Server Version : 80022
 Source Host           : localhost:3306
 Source Schema         : self-website

 Target Server Type    : MySQL
 Target Server Version : 80022
 File Encoding         : 65001

 Date: 30/06/2021 21:46:04
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for essay
-- ----------------------------
DROP TABLE IF EXISTS `essay`;
CREATE TABLE `essay` (
  `id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `markdown` varchar(11000) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `artical` varchar(10000) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `time` datetime NOT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `classify_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of essay
-- ----------------------------
BEGIN;
INSERT INTO `essay` VALUES ('20210320140517', '::: hljs-center\n\n# PC端能请求到服务器数据，但移动端请求不到数据\n\n:::\n\n## 起初服务器地址配置\n![截屏20210317 下午11.16.11.png](http://localhost:7002/images/20210320140201_.png)\n## 目前服务器地址的配置方式\n![截屏20210317 下午11.15.08.png](http://localhost:7002/images/20210320140225_.png)\n## 原因分析\n### http://127.0.0.1:7002\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;严格来说127.0.0.1只是环回地址之一。所有127.x.x.x都是环回地址。从127.0.0.0 到 127.255.255.255 均予以保留。此地址块中的任何地址都将环回到本地主机中。此地址块中的任何地址都绝不会出现在任何网络中。\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;环回地址：所有发往该类地址的数据包都应该被 loop back。正常的网络包从IP层进入数据链路层，然后发送到网络上， 而发向loopback地址的包，直接在IP层短路了，也就是发到IP层的包直接被IP层接收了，不再向下发送。\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;环回地址主要用来做回环测试，通过使用ping 127.0.0.1 测试某台机器上的网络设备，操作系统或者TCP/IP实现是否工作正常。\n### http://localhost:7002\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;非环回地址，这类网络地址的数据包不会被loop back。\n## 总结\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;本地测试时，可以尽量把服务器地址配置为network地址，而非环回地址，因为可能会出现上面提到的bug。', '<div class=\"hljs-center\">\n<h1><a id=\"PC_2\"></a>PC端能请求到服务器数据，但移动端请求不到数据</h1>\n</div>\n<h2><a id=\"_6\"></a>起初服务器地址配置</h2>\n<p><img src=\"http://localhost:7002/images/20210320140201_.png\" alt=\"截屏20210317 下午11.16.11.png\" /></p>\n<h2><a id=\"_8\"></a>目前服务器地址的配置方式</h2>\n<p><img src=\"http://localhost:7002/images/20210320140225_.png\" alt=\"截屏20210317 下午11.15.08.png\" /></p>\n<h2><a id=\"_10\"></a>原因分析</h2>\n<h3><a id=\"http1270017002_11\"></a>http://127.0.0.1:7002</h3>\n<p>       严格来说127.0.0.1只是环回地址之一。所有127.x.x.x都是环回地址。从127.0.0.0 到 127.255.255.255 均予以保留。此地址块中的任何地址都将环回到本地主机中。此地址块中的任何地址都绝不会出现在任何网络中。<br />\n       环回地址：所有发往该类地址的数据包都应该被 loop back。正常的网络包从IP层进入数据链路层，然后发送到网络上， 而发向loopback地址的包，直接在IP层短路了，也就是发到IP层的包直接被IP层接收了，不再向下发送。<br />\n       环回地址主要用来做回环测试，通过使用ping 127.0.0.1 测试某台机器上的网络设备，操作系统或者TCP/IP实现是否工作正常。</p>\n<h3><a id=\"http1921683287002_15\"></a>http://localhost:7002</h3>\n<p>       非环回地址，这类网络地址的数据包不会被loop back。</p>\n<h2><a id=\"_17\"></a>总结</h2>\n<p>       本地测试时，可以尽量把服务器地址配置为network地址，而非环回地址，因为可能会出现上面提到的bug。</p>\n', '2021-03-20 21:14:00', '移动端请求不到服务器数据', '20210317233307');
INSERT INTO `essay` VALUES ('20210320141202', '::: hljs-center\n\n# 发布按钮loading问题\n\n:::\n\n## 出现的问题\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;发布按钮loading与element-ui组件el-dialog不同步。即点击发布按钮后，呈现loading状态，并且弹出dialog组件。但是dialog组件隐藏后，发布按钮还呈现loading状态。\n## 解决途径\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;自定义一个watch监听element-ui组件中el-dialog的dialogFormVisible，其改变会关联到发布按钮抽象出来的属性loading。\n![截屏20210319 下午7.05.33.png](http://localhost:7002/images/20210320141124_.png)\n![截屏20210319 下午7.05.36.png](http://localhost:7002/images/20210320141133_.png)\n![截屏20210319 下午7.06.58.png](http://localhost:7002/images/20210320141140_.png)', '<div class=\"hljs-center\">\n<h1><a id=\"loading_2\"></a>发布按钮loading问题</h1>\n</div>\n<h2><a id=\"_6\"></a>出现的问题</h2>\n<p>      发布按钮loading与element-ui组件el-dialog不同步。即点击发布按钮后，呈现loading状态，并且弹出dialog组件。但是dialog组件隐藏后，发布按钮还呈现loading状态。</p>\n<h2><a id=\"_8\"></a>解决途径</h2>\n<p>      自定义一个watch监听element-ui组件中el-dialog的dialogFormVisible，其改变会关联到发布按钮抽象出来的属性loading。<br />\n<img src=\"http://localhost:7002/images/20210320141124_.png\" alt=\"截屏20210319 下午7.05.33.png\" /><br />\n<img src=\"http://localhost:7002/images/20210320141133_.png\" alt=\"截屏20210319 下午7.05.36.png\" /><br />\n<img src=\"http://localhost:7002/images/20210320141140_.png\" alt=\"截屏20210319 下午7.06.58.png\" /></p>\n', '2021-03-20 21:15:00', '发布按钮loading与element-ui组件中el-dialog显示隐藏不同步', '20210317233307');
INSERT INTO `essay` VALUES ('20210320144039', '::: hljs-center\n\n# eggjs抽取文章时，时间与发布时间相差8小时的问题\n\n:::\n\n## 解决途径\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;通过配置数据库中的timezone为\'08:00\'来解决。\n![截屏20210320 下午2.39.27.png](http://localhost:7002/images/20210320144014_.png)\n', '<div class=\"hljs-center\">\n<h1><a id=\"eggjs8_2\"></a>eggjs抽取文章时，时间与发布时间相差8小时的问题</h1>\n</div>\n<h2><a id=\"_6\"></a>解决途径</h2>\n<p>      通过配置数据库中的timezone为’08:00’来解决。<br />\n<img src=\"http://localhost:7002/images/20210320144014_.png\" alt=\"截屏20210320 下午2.39.27.png\" /></p>\n', '2021-03-20 21:16:00', '数据库抽出来的文章时间相差8小时问题', '20210317233307');
INSERT INTO `essay` VALUES ('20210320154440', '::: hljs-center\n\n# 关于我\n\n:::\n\n## 我是谁\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;我的笔名是火箭龟。\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;在校期间，我的身份是一名职业ACM竞赛生，从大一开始就参与到了这个竞赛中，并有幸成为了校队的一员。\n![b21bb051f8198618169533f649ed2e738ad4e6f6.png](http://localhost:7002/images/20210320152240_.png)\n## 我为什么入坑前端\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;在2020年的那个寒假，我在bilibili上无意间接触到了可视化的一个项目。而神奇的是，那不是数据可视化的项目，具体可以参考[可视化（我为什么入坑前端）](https://www.bilibili.com/video/BV14J411r72t)\n## 我与阿里的渊源\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;在我的成长过程中，经历过从最初的纸质支付，到现在的移动支付，支付宝无疑是最出名的。之后，高中生涯的我，我经常帮父母在天猫上网购。阿里的产品无时不刻的影响着我，在高中时，我就有了阿里的目标。\n### 作为一名练习生的我\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2020年的12月份，阿里推出了前端练习生计划，幸运的是我凭借自己扎实的基础通过了笔试，成为了阿里众多练习生的一员。在练习生的课程中，我学习到了很多前端领域最前沿的技术。在此之前，我一直认为掌握一门框架并且基础扎实，那么就可以算是一名合格的前端工程师。\n![v2d2c06c28855f0bca48851502f6598c00_r.jpg](http://localhost:7002/images/20210320153112_.jpg)\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;之后，我便发现我这种想法是很幼稚的。让我印象最深刻的就是low-code课程，随着低代码的出现，大大减少了前端工程师的开发量。\n## 我的目标\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;我的目标是成为一名在前端低代码领域的专家。没错，是专家。我希望，我能够在这一方面深入研究，降低大部分前端工程师的研发门槛。\n', '<div class=\"hljs-center\">\n<h1><a id=\"_2\"></a>关于我</h1>\n</div>\n<h2><a id=\"_6\"></a>我是谁</h2>\n<p>      我的笔名是火箭龟。<br />\n      在校期间，我的身份是一名职业ACM竞赛生，从大一开始就参与到了这个竞赛中，并有幸成为了校队的一员。<br />\n<img src=\"http://localhost:7002/images/20210320152240_.png\" alt=\"b21bb051f8198618169533f649ed2e738ad4e6f6.png\" /></p>\n<h2><a id=\"_10\"></a>我为什么入坑前端</h2>\n<p>      在2020年的那个寒假，我在bilibili上无意间接触到了可视化的一个项目。而神奇的是，那不是数据可视化的项目，具体可以参考<a href=\"https://www.bilibili.com/video/BV14J411r72t\" target=\"_blank\">可视化（我为什么入坑前端）</a></p>\n<h2><a id=\"_12\"></a>我与阿里的渊源</h2>\n<p>      在我的成长过程中，经历过从最初的纸质支付，到现在的移动支付，支付宝无疑是最出名的。之后，高中生涯的我，我经常帮父母在天猫上网购。阿里的产品无时不刻的影响着我，在高中时，我就有了阿里的目标。</p>\n<h3><a id=\"_14\"></a>作为一名练习生的我</h3>\n<p>      2020年的12月份，阿里推出了前端练习生计划，幸运的是我凭借自己扎实的基础通过了笔试，成为了阿里众多练习生的一员。在练习生的课程中，我学习到了很多前端领域最前沿的技术。在此之前，我一直认为掌握一门框架并且基础扎实，那么就可以算是一名合格的前端工程师。<br />\n<img src=\"http://localhost:7002/images/20210320153112_.jpg\" alt=\"v2d2c06c28855f0bca48851502f6598c00_r.jpg\" /><br />\n      之后，我便发现我这种想法是很幼稚的。让我印象最深刻的就是low-code课程，随着低代码的出现，大大减少了前端工程师的开发量。</p>\n<h2><a id=\"_18\"></a>我的目标</h2>\n<p>      我的目标是成为一名在前端低代码领域的专家。没错，是专家。我希望，我能够在这一方面深入研究，降低大部分前端工程师的研发门槛。</p>\n', '2021-03-20 15:44:00', '我是谁', '20210320152009');
INSERT INTO `essay` VALUES ('20210320191625', '::: hljs-center\n\n# 静态资源配置\n\n:::\n\n## 使用的依赖egg-static\n[egg-static文档说明](https://www.npmjs.com/package/egg-static)\n## 具体配置\n![截屏20210320 下午7.13.05.png](http://localhost:7002/images/20210320191352_.png)\n## 步骤\n### 拉取依赖包\n```\nnpm install egg-static --save\n\n```\n### 在config.default.js中配置图片静态资源\n```\n  // 配置图片\n  const userConfig = {\n    // myAppName: \'egg\',\n    static: {\n      prefix: \'/\',\n      dir: path.join(appInfo.baseDir, \'app/public\')\n    }\n  };\n\n```\n\n', '<div class=\"hljs-center\">\n<h1><a id=\"_2\"></a>静态资源配置</h1>\n</div>\n<h2><a id=\"eggstatic_6\"></a>使用的依赖egg-static</h2>\n<p><a href=\"https://www.npmjs.com/package/egg-static\" target=\"_blank\">egg-static文档说明</a></p>\n<h2><a id=\"_8\"></a>具体配置</h2>\n<p><img src=\"http://localhost:7002/images/20210320191352_.png\" alt=\"截屏20210320 下午7.13.05.png\" /></p>\n<h2><a id=\"_10\"></a>步骤</h2>\n<h3><a id=\"_11\"></a>拉取依赖包</h3>\n<pre><code class=\"lang-\">npm install egg-static --save\n\n</code></pre>\n<h3><a id=\"configdefaultjs_16\"></a>在config.default.js中配置图片静态资源</h3>\n<pre><code class=\"lang-\">  // 配置图片\n  const userConfig = {\n    // myAppName: \'egg\',\n    static: {\n      prefix: \'/\',\n      dir: path.join(appInfo.baseDir, \'app/public\')\n    }\n  };\n\n</code></pre>\n', '2021-03-20 21:17:00', '图片静态资源配置', '20210317233307');
INSERT INTO `essay` VALUES ('20210321211516', '::: hljs-center\n\n# 单页应用\n\n:::\n## 单页应用与多页应用\n![1006796201610281039228758866194532.png](http://localhost:7002/images/20210321204911_.png)\n![10067962016102810393110977013595.png](http://localhost:7002/images/20210321204923_.png)\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;由以上两张图可以很显然的看出单页应用和多页应用的区别。\n### 总结重要的两个区别\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1.单页应用切换页面的时候，并不是真正的切换整个页面，切换的只是页面片段，也可以理解为组件。这个过程是通过js监听url的变化来实现的，具体实现方式有两种，分别是hash和history。多页应用则切换的是货真价实的整个页面，每次切换都要建立tcp三次握手，都会有一个http请求响应的过程。\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2.单页应用不利于SEO，多页应用利于SEO。搜索引擎的本质就是通过url爬取html中的内容，但其不认识js渲染生成的内容。单页应用在首屏加载的时候请求到的html是个模型页面，可以理解为一个外壳，里面主体部分啥都没有，就只包含一个待被挂载或者替换的根节点，之后，js会根据url切换/渲染相应的组件。这就是为什么单页应用不利于SEO。\n### 对于Vue-cli搭建的单页应用，输入url到底发生了什么（阿里数字供应链一面）\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对于SPA(单页面应用)，当用户输入url时。首先会依次加载所有的资源，包括html/css/js等，因为SPA需要js去控制页面片段的切换，所以js文件一般体积会比较大并且比较多，因此，单页应用的首屏加载会比较慢。根据我的了解，在运行时版本中，首屏加载完毕后，js会去监听url的变化，拿到已经预编译好的渲染函数，直接将对应组件渲染到页面，实现页面的局部刷新，即将路由交由前端来做。但在非运行时版本，还会有一个模板编译阶段。解析器会根据模板在钩子函数中构建AST节点，然后搭建AST，并编译成渲染函数。', '<div class=\"hljs-center\">\n<h1><a id=\"_2\"></a>单页应用</h1>\n</div>\n<h2><a id=\"_5\"></a>单页应用与多页应用</h2>\n<p><img src=\"http://localhost:7002/images/20210321204911_.png\" alt=\"1006796201610281039228758866194532.png\" /><br />\n<img src=\"http://localhost:7002/images/20210321204923_.png\" alt=\"10067962016102810393110977013595.png\" /><br />\n      由以上两张图可以很显然的看出单页应用和多页应用的区别。</p>\n<h3><a id=\"_9\"></a>总结重要的两个区别</h3>\n<p>      1.单页应用切换页面的时候，并不是真正的切换整个页面，切换的只是页面片段，也可以理解为组件。这个过程是通过js监听url的变化来实现的，具体实现方式有两种，分别是hash和history。多页应用则切换的是货真价实的整个页面，每次切换都要建立tcp三次握手，都会有一个http请求响应的过程。<br />\n      2.单页应用不利于SEO，多页应用利于SEO。搜索引擎的本质就是通过url爬取html中的内容，但其不认识js渲染生成的内容。单页应用在首屏加载的时候请求到的html是个模型页面，可以理解为一个外壳，里面主体部分啥都没有，就只包含一个待被挂载或者替换的根节点，之后，js会根据url切换/渲染相应的组件。这就是为什么单页应用不利于SEO。</p>\n<h3><a id=\"Vuecliurl_12\"></a>对于Vue-cli搭建的单页应用，输入url到底发生了什么（阿里数字供应链一面）</h3>\n<p>      对于SPA(单页面应用)，当用户输入url时。首先会依次加载所有的资源，包括html/css/js等，因为SPA需要js去控制页面片段的切换，所以js文件一般体积会比较大并且比较多，因此，单页应用的首屏加载会比较慢。根据我的了解，在运行时版本中，首屏加载完毕后，js会去监听url的变化，拿到已经预编译好的渲染函数，直接将对应组件渲染到页面，实现页面的局部刷新，即将路由交由前端来做。但在非运行时版本，还会有一个模板编译阶段。解析器会根据模板在钩子函数中构建AST节点，然后搭建AST，并编译成渲染函数。</p>\n', '2021-03-21 21:15:00', '单页应用原理', '20210321204221');
INSERT INTO `essay` VALUES ('20210321215426', '::: hljs-center\n\n# eggjs搭建的服务器异步返回响应404问题\n\n:::\n## 根据项目中遇到的问题，具体抽象出一个原理差不多的demo\n![截屏20210321 下午9.44.20.png](http://localhost:7002/images/20210321214553_.png)\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;一开始项目中写的方式和这个差不多，很明显的意图，我想要从数据库中取到数据，然后返回给前端。这样写有什么问题？首先代码从上到下执行，遇到promise的then方法，将其中的微任务回调仍到微任务队列，继续向下执行。那么，发现当前执行栈中没有内容返回的任务，就直接返回404响应。\n![截屏20210321 下午9.44.47.png](http://localhost:7002/images/20210321214946_.png)\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;之后，想了下原因，就写成了上面那样。我使用await直接定死异步任务，必须等数据库中成功取到数据才能继续向下执行，返回响应体。\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;OK!成功解决。', '<div class=\"hljs-center\">\n<h1><a id=\"eggjs404_2\"></a>eggjs搭建的服务器异步返回响应404问题</h1>\n</div>\n<h2><a id=\"demo_5\"></a>根据项目中遇到的问题，具体抽象出一个原理差不多的demo</h2>\n<p><img src=\"http://localhost:7002/images/20210321214553_.png\" alt=\"截屏20210321 下午9.44.20.png\" /><br />\n      一开始项目中写的方式和这个差不多，很明显的意图，我想要从数据库中取到数据，然后返回给前端。这样写有什么问题？首先代码从上到下执行，遇到promise的then方法，将其中的微任务回调仍到微任务队列，继续向下执行。那么，发现当前执行栈中没有内容返回的任务，就直接返回404响应。<br />\n<img src=\"http://localhost:7002/images/20210321214946_.png\" alt=\"截屏20210321 下午9.44.47.png\" /><br />\n      之后，想了下原因，就写成了上面那样。我使用await直接定死异步任务，必须等数据库中成功取到数据才能继续向下执行，返回响应体。<br />\n      OK!成功解决。</p>\n', '2021-03-22 00:42:00', '服务器返回404', '20210317233307');
INSERT INTO `essay` VALUES ('20210322004116', '::: hljs-center\n\n# 重构接口\n\n:::\n## 重构eggjs的app目录下的router.js模块中的接口\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;从语义化出发重构接口。\n![截屏20210322 上午12.29.48.png](http://localhost:7002/images/20210322003821_.png)\n## 重构后台管理中的config下的net.js模块下的接口\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;从可维护性出发，将所有接口的配置放入这个模块。在需要的地方直接导入即可使用。\n![截屏20210322 上午12.29.53.png](http://localhost:7002/images/20210322004006_.png)', '<div class=\"hljs-center\">\n<h1><a id=\"_2\"></a>重构接口</h1>\n</div>\n<h2><a id=\"eggjsapprouterjs_5\"></a>重构eggjs的app目录下的router.js模块中的接口</h2>\n<p>      从语义化出发重构接口。<br />\n<img src=\"http://localhost:7002/images/20210322003821_.png\" alt=\"截屏20210322 上午12.29.48.png\" /></p>\n<h2><a id=\"confignetjs_8\"></a>重构后台管理中的config下的net.js模块下的接口</h2>\n<p>      从可维护性出发，将所有接口的配置放入这个模块。在需要的地方直接导入即可使用。<br />\n<img src=\"http://localhost:7002/images/20210322004006_.png\" alt=\"截屏20210322 上午12.29.53.png\" /></p>\n', '2021-03-22 00:41:00', '重构接口', '20210317233307');
INSERT INTO `essay` VALUES ('20210322174051', '::: hljs-center\n\n# webpack初体验\n\n:::\n## webpack是什么\n![截屏20210322 下午5.31.01.png](http://localhost:7002/images/20210322173209_.png)\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;webpack是一个用于现代JavaScript应用程序的静态模块打包工具。\n## webpack打包的具体过程\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;首先从一个入口文件开始构建各个模块的依赖关系图，生成chunk代码块，之后通过webpack打包输出bundle。\n## 安装建议\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;建议安装webpack@4.0.0，webpack-cli@3.3.12。笔者在两个都安装最新版本的情况下，打包输出出现了问题。\n### 全局安装\n```\nnpm install webpack@4.0.0 webpack-cli@3.3.12 -g\n\n```\n### 指令初体验\n\n```\n//构建开发环境版本，从./src/index.js出发构建模块依赖关系图，输出bundle至./build/built.js\nwebpack ./src/index.js -o ./build/built.js --mode=development\n//构建生产环境版本，从./src/index.js出发构建模块依赖关系图，输出bundle至./build/built.js\nwebpack ./src/index.js -o ./build/built.js --mode=production\n\n```\n\n', '<div class=\"hljs-center\">\n<h1><a id=\"webpack_2\"></a>webpack初体验</h1>\n</div>\n<h2><a id=\"webpack_5\"></a>webpack是什么</h2>\n<p><img src=\"http://localhost:7002/images/20210322173209_.png\" alt=\"截屏20210322 下午5.31.01.png\" /><br />\n      webpack是一个用于现代JavaScript应用程序的静态模块打包工具。</p>\n<h2><a id=\"webpack_8\"></a>webpack打包的具体过程</h2>\n<p>      首先从一个入口文件开始构建各个模块的依赖关系图，生成chunk代码块，之后通过webpack打包输出bundle。</p>\n<h2><a id=\"_10\"></a>安装建议</h2>\n<p>      建议安装webpack@4.0.0，webpack-cli@3.3.12。笔者在两个都安装最新版本的情况下，打包输出出现了问题。</p>\n<h3><a id=\"_12\"></a>全局安装</h3>\n<pre><code class=\"lang-\">npm install webpack@4.0.0 webpack-cli@3.3.12 -g\n\n</code></pre>\n<h3><a id=\"_17\"></a>指令初体验</h3>\n<pre><code class=\"lang-\">//构建开发环境版本，从./src/index.js出发构建模块依赖关系图，输出bundle至./build/built.js\nwebpack ./src/index.js -o ./build/built.js --mode=development\n//构建生产环境版本，从./src/index.js出发构建模块依赖关系图，输出bundle至./build/built.js\nwebpack ./src/index.js -o ./build/built.js --mode=production\n\n</code></pre>\n', '2021-03-22 17:40:00', 'webpack初体验', '20210322171114');
INSERT INTO `essay` VALUES ('20210323191343', '::: hljs-center\n\n# webpack打包样式资源(注意loader的版本问题)\n\n:::\n## 配置\n```\nnpm install css-loader@3.6.0 style-loader@2.0.0 -D\n\n```\n\n![截屏20210323 下午7.08.08.png](http://localhost:7002/images/20210323190830_.png)\n## 重点解释说明\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;webpack本事只识别js文件，不识别css等其它文件，所以需要loader这样翻译官的角色。loader需要在modules里配置。test去匹配文件后缀名，对于匹配到的文件，应用use里配置的\"翻译官\"来翻译这些文件。\"翻译官\"的执行顺序是从下到上，从右到左的，所以需要注意顺序。', '<div class=\"hljs-center\">\n<h1><a id=\"webpackloader_2\"></a>webpack打包样式资源(注意loader的版本问题)</h1>\n</div>\n<h2><a id=\"_5\"></a>配置</h2>\n<pre><code class=\"lang-\">npm install css-loader@3.6.0 style-loader@2.0.0 -D\n\n</code></pre>\n<p><img src=\"http://localhost:7002/images/20210323190830_.png\" alt=\"截屏20210323 下午7.08.08.png\" /></p>\n<h2><a id=\"_12\"></a>重点解释说明</h2>\n<p>      webpack本事只识别js文件，不识别css等其它文件，所以需要loader这样翻译官的角色。loader需要在modules里配置。test去匹配文件后缀名，对于匹配到的文件，应用use里配置的&quot;翻译官&quot;来翻译这些文件。&quot;翻译官&quot;的执行顺序是从下到上，从右到左的，所以需要注意顺序。</p>\n', '2021-03-23 21:23:00', 'webpack打包样式资源(css)', '20210322171114');
INSERT INTO `essay` VALUES ('20210323212238', '::: hljs-center\n\n# webpack打包html资源(注意plugin的版本问题)\n\n:::\n## 配置\n```\nnpm install html-webpack-plugin@4.5.0 -D\n\n```\n\n![截屏20210323 下午9.13.44.png](http://localhost:7002/images/20210323211551_.png)\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;这个插件会根据template属性自动去找html模板文件并复制。之后，会自动引入打包好的文件，例如，js、css等。\n\n', '<div class=\"hljs-center\">\n<h1><a id=\"webpackhtmlplugin_2\"></a>webpack打包html资源(注意plugin的版本问题)</h1>\n</div>\n<h2><a id=\"_5\"></a>配置</h2>\n<pre><code class=\"lang-\">npm install html-webpack-plugin@4.5.0 -D\n\n</code></pre>\n<p><img src=\"http://localhost:7002/images/20210323211551_.png\" alt=\"截屏20210323 下午9.13.44.png\" /><br />\n      这个插件会根据template属性自动去找html模板文件并复制。之后，会自动引入打包好的文件，例如，js、css等。</p>\n', '2021-03-23 21:22:00', 'webpack打包html资源', '20210322171114');
INSERT INTO `essay` VALUES ('20210323223101', '::: hljs-center\n\n# webpack打包图片\n\n:::\n## 目录结构\n![截屏20210323 下午10.23.18.png](http://localhost:7002/images/20210323222435_.png)\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;其中index.css中引用了两张图片。\n### package.json\n![截屏20210323 下午10.26.23.png](http://localhost:7002/images/20210323222701_.png)\n### webpack.config.js\n```\nconst { resolve } = require(\'path\');\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\');\n\nmodule.exports = {\n  entry: \'./src/main.js\',\n  \n  output: {\n    filename: \'built.js\',\n    path: resolve(__dirname, \'build\'),\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          \'style-loader\',\n          \'css-loader\'\n        ]\n      },\n      {\n        //匹配以.jpg/.png/.gif结尾的图片\n        test: /\\.(jpg|png|gif)$/,\n        loader: \'url-loader\',\n        options: {\n          //小于等于8K的图片以base64编码\n          //优点：减少请数量\n          //缺点：体积变大\n          limit: 8 * 1024,\n          //url-loader默认以ES6模块去解析，会和html-loader的commonjs模块冲突，所以需要关闭\n          esModule: false,\n          //只保留10位hash值\n          name:\'[hash:10].[ext]\'\n        }\n      },\n      // {\n      //   test: /\\.html$/,\n      //   loader:\'html-loader\'\n      // }\n    ]\n  },\n\n  plugins: [\n    new HtmlWebpackPlugin({\n      template:\'./src/index.html\'\n    })\n  ],\n\n  mode:\'development\'\n}\n\n```\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;以上这种配置能打包css中引用的图片。但存在一种情况，通过在index.html中通过img标签以./logo.png的形式引用图片，不会被打包。这时，需要使用html-loader，打包过程中报错（待解决）。\n\n', '<div class=\"hljs-center\">\n<h1><a id=\"webpack_2\"></a>webpack打包图片</h1>\n</div>\n<h2><a id=\"_5\"></a>目录结构</h2>\n<p><img src=\"http://localhost:7002/images/20210323222435_.png\" alt=\"截屏20210323 下午10.23.18.png\" /><br />\n      其中index.css中引用了两张图片。</p>\n<h3><a id=\"packagejson_8\"></a>package.json</h3>\n<p><img src=\"http://localhost:7002/images/20210323222701_.png\" alt=\"截屏20210323 下午10.26.23.png\" /></p>\n<h3><a id=\"webpackconfigjs_10\"></a>webpack.config.js</h3>\n<pre><code class=\"lang-\">const { resolve } = require(\'path\');\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\');\n\nmodule.exports = {\n  entry: \'./src/main.js\',\n  \n  output: {\n    filename: \'built.js\',\n    path: resolve(__dirname, \'build\'),\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          \'style-loader\',\n          \'css-loader\'\n        ]\n      },\n      {\n        //匹配以.jpg/.png/.gif结尾的图片\n        test: /\\.(jpg|png|gif)$/,\n        loader: \'url-loader\',\n        options: {\n          //小于等于8K的图片以base64编码\n          //优点：减少请数量\n          //缺点：体积变大\n          limit: 8 * 1024,\n          //url-loader默认以ES6模块去解析，会和html-loader的commonjs模块冲突，所以需要关闭\n          esModule: false,\n          //只保留10位hash值\n          name:\'[hash:10].[ext]\'\n        }\n      },\n      // {\n      //   test: /\\.html$/,\n      //   loader:\'html-loader\'\n      // }\n    ]\n  },\n\n  plugins: [\n    new HtmlWebpackPlugin({\n      template:\'./src/index.html\'\n    })\n  ],\n\n  mode:\'development\'\n}\n\n</code></pre>\n<p>      以上这种配置能打包css中引用的图片。但存在一种情况，通过在index.html中通过img标签以./logo.png的形式引用图片，不会被打包。这时，需要使用html-loader，打包过程中报错（待解决）。</p>\n', '2021-03-23 22:31:00', 'webpack打包图片', '20210322171114');
INSERT INTO `essay` VALUES ('20210326225948', '# webpack打包图片（html文件中引用图片的情况）\n## 解决途径\n```\nnpm install html-loader@1.3.2 -D\n\n```\n注意html-loader版本问题，2.0.0及以上版本，打包输出bundle会报错。\n## package.json\n![截屏20210326 下午10.55.53.png](http://localhost:7002/images/20210326225838_.png)\n## webpack.config.js\n```\nconst { resolve } = require(\'path\');\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\');\n\nmodule.exports = {\n  entry: \'./src/main.js\',\n  \n  output: {\n    filename: \'built.js\',\n    path: resolve(__dirname, \'build\'),\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          \'style-loader\',\n          \'css-loader\'\n        ]\n      },\n      {\n        //匹配以.jpg/.png/.gif结尾的图片\n        test: /\\.(jpg|png|gif)$/,\n        loader: \'url-loader\',\n        options: {\n          //小于等于8K的图片以base64编码\n          //优点：减少请数量\n          //缺点：体积变大\n          limit: 8 * 1024,\n          //url-loader默认以ES6模块去解析，会和html-loader的commonjs模块冲突，所以需要关闭\n          esModule: false,\n          //只保留10位hash值\n          name:\'[hash:10].[ext]\'\n        }\n      },\n      {\n        test: /\\.html$/,\n        loader:\'html-loader\'\n      }\n    ]\n  },\n\n  plugins: [\n    new HtmlWebpackPlugin({\n      template:\'./src/index.html\'\n    })\n  ],\n\n  mode:\'development\'\n}\n\n```\n\n', '<h1><a id=\"webpackhtml_0\"></a>webpack打包图片（html文件中引用图片的情况）</h1>\n<h2><a id=\"_1\"></a>解决途径</h2>\n<pre><code class=\"lang-\">npm install html-loader@1.3.2 -D\n\n</code></pre>\n<p>注意html-loader版本问题，2.0.0及以上版本，打包输出bundle会报错。</p>\n<h2><a id=\"packagejson_7\"></a>package.json</h2>\n<p><img src=\"http://localhost:7002/images/20210326225838_.png\" alt=\"截屏20210326 下午10.55.53.png\" /></p>\n<h2><a id=\"webpackconfigjs_9\"></a>webpack.config.js</h2>\n<pre><code class=\"lang-\">const { resolve } = require(\'path\');\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\');\n\nmodule.exports = {\n  entry: \'./src/main.js\',\n  \n  output: {\n    filename: \'built.js\',\n    path: resolve(__dirname, \'build\'),\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          \'style-loader\',\n          \'css-loader\'\n        ]\n      },\n      {\n        //匹配以.jpg/.png/.gif结尾的图片\n        test: /\\.(jpg|png|gif)$/,\n        loader: \'url-loader\',\n        options: {\n          //小于等于8K的图片以base64编码\n          //优点：减少请数量\n          //缺点：体积变大\n          limit: 8 * 1024,\n          //url-loader默认以ES6模块去解析，会和html-loader的commonjs模块冲突，所以需要关闭\n          esModule: false,\n          //只保留10位hash值\n          name:\'[hash:10].[ext]\'\n        }\n      },\n      {\n        test: /\\.html$/,\n        loader:\'html-loader\'\n      }\n    ]\n  },\n\n  plugins: [\n    new HtmlWebpackPlugin({\n      template:\'./src/index.html\'\n    })\n  ],\n\n  mode:\'development\'\n}\n\n</code></pre>\n', '2021-03-26 22:59:00', 'webpack打包图片资源（解决html中引入图片之后打包输出问题）', '20210322171114');
INSERT INTO `essay` VALUES ('20210328000719', '::: hljs-center\n\n# 重构eggjs端（缓存性能优化）\n\n:::\n## 实现途径\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;主要是通过借鉴[js模块加载器原理](https://www.zhihu.com/question/21157540)和[Vue.extend全局API源码分析](https://blog.csdn.net/weixin_43916777/article/details/111404326?spm=1001.2014.3001.5501)中的缓存策略的实现来落地自己的思想。\n### 具有代表性模块的实现\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;service文件夹下的handleArtical.js模块\n```\n\'use strict\';\n\nconst Service = require(\'egg\').Service;\nconst dateFormat = require(\'dateformat\');\nvar sd = require(\'silly-datetime\');\n\nclass HandleArticalService extends Service {\n\n  static resources = {\n    cache: {}\n  };\n\n  async addArtical(obj) {\n    const id = dateFormat(new Date(), \"yyyymmddHHMMss\");\n    const markdown = obj.fields.markdown;\n    const artical = obj.fields.artical;\n    const time = sd.format(new Date(), \'YYYY-MM-DD HH:mm\');\n    const title = obj.fields.title;\n    const classify_id = obj.fields.classify_id;\n    const essay = {\n      id,\n      markdown,\n      artical,\n      time,\n      title,\n      classify_id\n    };\n    const result = await this.app.mysql.insert(\'essay\', essay);\n    /*\n    当按分类存取文章时，重置其对应分类的缓存\n    */\n    this.resetResources(`getArticalsByClassifyId${classify_id}`) = undefined;\n    return result;\n  }\n\n  async deleteArtical(id) {\n    /*\n    当删除文章时，重置其对应分类的缓存\n     */\n    const essay = await this.app.mysql.get(\"essay\", { id });\n    await this.app.mysql.delete(\'essay\', { id });\n    this.resetResources(`getArticalsByClassifyId${essay.classify_id}`) \n= undefined;\n  }\n  \n  async getArtical(id) {\n    const essay = await this.app.mysql.get(\"essay\", { id });\n    return essay;\n  }\n\n  async getArticalsByClassifyId(id) {\n    /*\n    考虑eggjs搭建的服务器端的缓存优化\n    不让处理请求逻辑一直去操作数据库\n    */\n    if (HandleArticalService.resources[`getArticalsByClassifyId${id}`]) \nreturn HandleArticalService.resources[`getArticalsByClassifyId${id}`];\n    const essays = await this.app.mysql.select(\"essay\", {      \n      where: { classify_id: id }\n    });\n    HandleArticalService.resources[`getArticalsByClassifyId${id}`] = essays;\n    return essays;\n  }\n\n  async updateArtical(obj) {\n    const id = obj.fields.id;\n    const markdown = obj.fields.markdown;\n    const artical = obj.fields.artical;\n    let time = sd.format(new Date(), \'YYYY-MM-DD HH:mm\');\n    const title = obj.fields.title;\n    const classify_id = obj.fields.classify_id;\n    const essay = {\n      id,\n      markdown,\n      artical,\n      time,\n      title,\n      classify_id\n    };\n    const result = await this.app.mysql.update(\'essay\', essay); \n    const updateSuccess = result.affectedRows === 1;\n    /*\n    当更新分类时，重置其对应分类的缓存\n    */\n    this.resetResources(`getArticalsByClassifyId${classify_id}`) = undefined;\n    return updateSuccess;\n  }\n\n  async getArticalAboutMe() {\n    const essay = await this.app.mysql.get(\"essay\", { title:\'关于我\' });\n    return essay;\n  }\n\n  resetResources(cacheStr) {\n    HandleArticalService.resources[cacheStr] = undefined;\n  }\n}\n\nmodule.exports = HandleArticalService;\n\n```\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;service文件夹下的classify.js模块\n```\n\'use strict\';\n\nconst Controller = require(\'egg\').Controller;\nconst formidable = require(\'formidable\');\n\nclass ClassifyController extends Controller {\n  async getClassifies() {\n    const { ctx } = this;\n    const classifies = await ctx.service.classify.getClassifies();\n    ctx.body = classifies;\n  }\n\n  async publishClassify() {\n    const { ctx } = this;\n    const { req } = ctx;\n    const form = new formidable.IncomingForm();\n    let rel = await new Promise((resolve, reject) => {\n      form.parse(req, (err, fields, files) => {\n        resolve({ fields, files });\n      });\n    }).then(obj => {\n      return ctx.service.classify.addClassify(obj);\n    });\n    if (rel) {\n      ctx.status = 200;\n      ctx.body = rel;\n    } else {\n      ctx.status = 409;\n      ctx.body = \'分类已存在\';\n    }\n  }\n\n  async deleteClassify() {\n    const { ctx } = this;\n    const classify_id = ctx.request.body.classify_id;\n    console.log(\'classify_id\', classify_id);\n    await ctx.service.classify.deleteClassify(classify_id);\n    ctx.status = 200;\n    ctx.body = \'分类删除成功\';\n  }\n}\n\nmodule.exports = ClassifyController;\n\n\n```\n\n\n## 对eggjs缓存实现的思考\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;这种实现方案的优点是很明显的，就是对于文章的按类拉取不用每次都去操作数据库，在一定程度上节约了时间。\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;缺点也是很明显的，笔者的这种实现方式，实质上就是把缓存的资源压入了服务器内存中。那么，存在一个可能的问题，就是对于企业级应用来说，缓存的资源数量很大，那么针对部署在低内存的云服务器的情况，可能会造成整个应用卡死或者说内存爆炸。因此，我借鉴了[100万条数据占用多少空间](https://blog.csdn.net/jing_xin/article/details/87938988?ops_request_misc=&request_id=&biz_id=102&utm_term=1000篇博客占多少数据库内存&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-87938988.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187)。选择了一个折中的方案，对文章的按类拉取进行缓存。因为，项目的“toB”端针对的对象只有笔者一个人，假设每天写5篇文章，那么十年差不多有2万篇，也不是很多。同时，我是按类缓存文章的，也存在一定的内存优化，所以我认为这种egg端的缓存方案适合在我的个人项目中落地。', '<div class=\"hljs-center\">\n<h1><a id=\"eggjs_2\"></a>重构eggjs端（缓存性能优化）</h1>\n</div>\n<h2><a id=\"_5\"></a>实现途径</h2>\n<p>      主要是通过借鉴<a href=\"https://www.zhihu.com/question/21157540\" target=\"_blank\">js模块加载器原理</a>和<a href=\"https://blog.csdn.net/weixin_43916777/article/details/111404326?spm=1001.2014.3001.5501\" target=\"_blank\">Vue.extend全局API源码分析</a>中的缓存策略的实现来落地自己的思想。</p>\n<h3><a id=\"_7\"></a>具有代表性模块的实现</h3>\n<p>      service文件夹下的handleArtical.js模块</p>\n<pre><code class=\"lang-\">\'use strict\';\n\nconst Service = require(\'egg\').Service;\nconst dateFormat = require(\'dateformat\');\nvar sd = require(\'silly-datetime\');\n\nclass HandleArticalService extends Service {\n\n  static resources = {\n    cache: {}\n  };\n\n  async addArtical(obj) {\n    const id = dateFormat(new Date(), &quot;yyyymmddHHMMss&quot;);\n    const markdown = obj.fields.markdown;\n    const artical = obj.fields.artical;\n    const time = sd.format(new Date(), \'YYYY-MM-DD HH:mm\');\n    const title = obj.fields.title;\n    const classify_id = obj.fields.classify_id;\n    const essay = {\n      id,\n      markdown,\n      artical,\n      time,\n      title,\n      classify_id\n    };\n    const result = await this.app.mysql.insert(\'essay\', essay);\n    /*\n    当按分类存取文章时，重置其对应分类的缓存\n    */\n    this.resetResources(`getArticalsByClassifyId${classify_id}`) = undefined;\n    return result;\n  }\n\n  async deleteArtical(id) {\n    /*\n    当删除文章时，重置其对应分类的缓存\n     */\n    const essay = await this.app.mysql.get(&quot;essay&quot;, { id });\n    await this.app.mysql.delete(\'essay\', { id });\n    this.resetResources(`getArticalsByClassifyId${essay.classify_id}`) \n= undefined;\n  }\n  \n  async getArtical(id) {\n    const essay = await this.app.mysql.get(&quot;essay&quot;, { id });\n    return essay;\n  }\n\n  async getArticalsByClassifyId(id) {\n    /*\n    考虑eggjs搭建的服务器端的缓存优化\n    不让处理请求逻辑一直去操作数据库\n    */\n    if (HandleArticalService.resources[`getArticalsByClassifyId${id}`]) \nreturn HandleArticalService.resources[`getArticalsByClassifyId${id}`];\n    const essays = await this.app.mysql.select(&quot;essay&quot;, {      \n      where: { classify_id: id }\n    });\n    HandleArticalService.resources[`getArticalsByClassifyId${id}`] = essays;\n    return essays;\n  }\n\n  async updateArtical(obj) {\n    const id = obj.fields.id;\n    const markdown = obj.fields.markdown;\n    const artical = obj.fields.artical;\n    let time = sd.format(new Date(), \'YYYY-MM-DD HH:mm\');\n    const title = obj.fields.title;\n    const classify_id = obj.fields.classify_id;\n    const essay = {\n      id,\n      markdown,\n      artical,\n      time,\n      title,\n      classify_id\n    };\n    const result = await this.app.mysql.update(\'essay\', essay); \n    const updateSuccess = result.affectedRows === 1;\n    /*\n    当更新分类时，重置其对应分类的缓存\n    */\n    this.resetResources(`getArticalsByClassifyId${classify_id}`) = undefined;\n    return updateSuccess;\n  }\n\n  async getArticalAboutMe() {\n    const essay = await this.app.mysql.get(&quot;essay&quot;, { title:\'关于我\' });\n    return essay;\n  }\n\n  resetResources(cacheStr) {\n    HandleArticalService.resources[cacheStr] = undefined;\n  }\n}\n\nmodule.exports = HandleArticalService;\n\n</code></pre>\n<p>      service文件夹下的classify.js模块</p>\n<pre><code class=\"lang-\">\'use strict\';\n\nconst Controller = require(\'egg\').Controller;\nconst formidable = require(\'formidable\');\n\nclass ClassifyController extends Controller {\n  async getClassifies() {\n    const { ctx } = this;\n    const classifies = await ctx.service.classify.getClassifies();\n    ctx.body = classifies;\n  }\n\n  async publishClassify() {\n    const { ctx } = this;\n    const { req } = ctx;\n    const form = new formidable.IncomingForm();\n    let rel = await new Promise((resolve, reject) =&gt; {\n      form.parse(req, (err, fields, files) =&gt; {\n        resolve({ fields, files });\n      });\n    }).then(obj =&gt; {\n      return ctx.service.classify.addClassify(obj);\n    });\n    if (rel) {\n      ctx.status = 200;\n      ctx.body = rel;\n    } else {\n      ctx.status = 409;\n      ctx.body = \'分类已存在\';\n    }\n  }\n\n  async deleteClassify() {\n    const { ctx } = this;\n    const classify_id = ctx.request.body.classify_id;\n    console.log(\'classify_id\', classify_id);\n    await ctx.service.classify.deleteClassify(classify_id);\n    ctx.status = 200;\n    ctx.body = \'分类删除成功\';\n  }\n}\n\nmodule.exports = ClassifyController;\n\n\n</code></pre>\n<h2><a id=\"eggjs_161\"></a>对eggjs缓存实现的思考</h2>\n<p>      这种实现方案的优点是很明显的，就是对于文章的按类拉取不用每次都去操作数据库，在一定程度上节约了时间。<br />\n      缺点也是很明显的，笔者的这种实现方式，实质上就是把缓存的资源压入了服务器内存中。那么，存在一个可能的问题，就是对于企业级应用来说，缓存的资源数量很大，那么针对部署在低内存的云服务器的情况，可能会造成整个应用卡死或者说内存爆炸。因此，我借鉴了<a href=\"https://blog.csdn.net/jing_xin/article/details/87938988?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=1000%E7%AF%87%E5%8D%9A%E5%AE%A2%E5%8D%A0%E5%A4%9A%E5%B0%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-87938988.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187\" target=\"_blank\">100万条数据占用多少空间</a>。选择了一个折中的方案，对文章的按类拉取进行缓存。因为，项目的“toB”端针对的对象只有笔者一个人，假设每天写5篇文章，那么十年差不多有2万篇，也不是很多。同时，我是按类缓存文章的，也存在一定的内存优化，所以我认为这种egg端的缓存方案适合在我的个人项目中落地。</p>\n', '2021-03-28 13:13:00', '重构eggjs端（缓存性能优化）', '20210317233307');
INSERT INTO `essay` VALUES ('20210330123507', '::: hljs-center\n\n# dev-server启动后浏览器控制台报错\n\n:::\n## 具体情况\n![截屏20210329 下午10.32.55.png](http://localhost:7002/images/20210330123113_.png)\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;使用dev-server在内存中操作打包，出现了这种错误。html中对应的head标签内也没有插入对应的style标签。\n## 原因\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;入口文件js部分语法存在错误\n```\nimport \'./index.css\';\n\nfunction add(x, y) {\n  return x + y;\n}\n\nconsole.log(add(1 + 2));\n\n```\n应该改为\n```\nimport \'./index.css\';\n\nfunction add(x, y) {\n  return x + y;\n}\n\nconsole.log(add(1, 2));\n\n```\n\n', '<div class=\"hljs-center\">\n<h1><a id=\"devserver_2\"></a>dev-server启动后浏览器控制台报错</h1>\n</div>\n<h2><a id=\"_5\"></a>具体情况</h2>\n<p><img src=\"http://localhost:7002/images/20210330123113_.png\" alt=\"截屏20210329 下午10.32.55.png\" /><br />\n      使用dev-server在内存中操作打包，出现了这种错误。html中对应的head标签内也没有插入对应的style标签。</p>\n<h2><a id=\"_8\"></a>原因</h2>\n<p>      入口文件js部分语法存在错误</p>\n<pre><code class=\"lang-\">import \'./index.css\';\n\nfunction add(x, y) {\n  return x + y;\n}\n\nconsole.log(add(1 + 2));\n\n</code></pre>\n<p>应该改为</p>\n<pre><code class=\"lang-\">import \'./index.css\';\n\nfunction add(x, y) {\n  return x + y;\n}\n\nconsole.log(add(1, 2));\n\n</code></pre>\n', '2021-03-30 12:35:00', 'dev-server启动后浏览器控制台报错', '20210322171114');
INSERT INTO `essay` VALUES ('20210330131806', '::: hljs-center\n\n# 开发环境基本配置\n\n:::\n## demo的基本结构\n![截屏20210330 下午1.16.00.png](http://localhost:7002/images/20210330131724_.png)\n## webpack.config.js\n```\nconst { resolve } = require(\'path\');\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\');\n\nmodule.exports = {\n  entry: \'./src/js/index.js\',\n  \n  output: {\n    filename: \'js/built.js\',\n    path: resolve(__dirname, \'build\')\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\'style-loader\', \'css-loader\'],\n      },\n      {\n        test: /\\.less$/,\n        use: [\'style-loader\', \'css-loader\', \'less-loader\']\n      },\n      {\n        test: /\\.(jpg|png|gif)$/,\n        loader: \'url-loader\',\n        options: {\n          limit: 8 * 1024,\n          esModule: false,\n          name: \'[hash:10].[ext]\',\n          outputPath: \'image\'\n        }\n      },\n      {\n        test: /\\.html$/,\n        loader: \'html-loader\'\n      },\n      {\n        exclude: /\\.(html|js|css|less|jpg|png|gif)$/,\n        loader: \'file-loader\',\n        options: {\n          name: \'[hash:10].[ext]\',\n          outputPath: \'icon\'\n        }\n      }\n    ]\n  },\n\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: \'./src/index.html\'\n    })\n  ],\n\n  mode: \'development\',\n  \n  devServer: {\n    contentBase: resolve(__dirname, \'build\'),\n    compress: true,\n    port: 3000,\n    open: true,\n  }\n}\n\n```\n', '<div class=\"hljs-center\">\n<h1><a id=\"_2\"></a>开发环境基本配置</h1>\n</div>\n<h2><a id=\"demo_5\"></a>demo的基本结构</h2>\n<p><img src=\"http://localhost:7002/images/20210330131724_.png\" alt=\"截屏20210330 下午1.16.00.png\" /></p>\n<h2><a id=\"webpackconfigjs_7\"></a>webpack.config.js</h2>\n<pre><code class=\"lang-\">const { resolve } = require(\'path\');\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\');\n\nmodule.exports = {\n  entry: \'./src/js/index.js\',\n  \n  output: {\n    filename: \'js/built.js\',\n    path: resolve(__dirname, \'build\')\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\'style-loader\', \'css-loader\'],\n      },\n      {\n        test: /\\.less$/,\n        use: [\'style-loader\', \'css-loader\', \'less-loader\']\n      },\n      {\n        test: /\\.(jpg|png|gif)$/,\n        loader: \'url-loader\',\n        options: {\n          limit: 8 * 1024,\n          esModule: false,\n          name: \'[hash:10].[ext]\',\n          outputPath: \'image\'\n        }\n      },\n      {\n        test: /\\.html$/,\n        loader: \'html-loader\'\n      },\n      {\n        exclude: /\\.(html|js|css|less|jpg|png|gif)$/,\n        loader: \'file-loader\',\n        options: {\n          name: \'[hash:10].[ext]\',\n          outputPath: \'icon\'\n        }\n      }\n    ]\n  },\n\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: \'./src/index.html\'\n    })\n  ],\n\n  mode: \'development\',\n  \n  devServer: {\n    contentBase: resolve(__dirname, \'build\'),\n    compress: true,\n    port: 3000,\n    open: true,\n  }\n}\n\n</code></pre>\n', '2021-03-30 13:18:00', '开发环境基本配置', '20210322171114');
INSERT INTO `essay` VALUES ('20210625090834', 'hello world', '<p>hello world</p>\n', '2021-06-30 21:39:00', '333', '20210317233307');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
